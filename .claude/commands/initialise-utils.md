# Initialise utils

## Important

- Create each script in order, verify that each one works correctly before moving onto the next, get confirmation to move onto the next script.
- If the script already exists then just verify that it works correctly before moving onto the next item, if it does not work correctly then delete the file and create the script from scratch.
- When writing scripts that use dotnet make sure to disable MSBuild node reuse to prevent hanging processes (e.g. export MSBUILDDISABLENODEREUSE=1)
- Dotnet build requires several parameters to sport lingering processes, e.g. dotnet build src/GraphlessDB.sln --no-incremental -p:UseSharedCompilation=false -p:UseRazorBuildServer=false /nodeReuse:false --verbosity quiet

## Request

Create the following utility scripts in order:

- Create a utility script (called run-build.sh) in ./utils which can run build all the projects.
- Create a utility script (called run-tests.sh) in ./utils which can run all unit tests.
- Create a utility script (called get-solution-coverage.sh) in ./utils which runs code coverage using all unit tests.  The script should store any intermediate coverage files to a uniquely named folder under ".coverage" folder which is to be located at the project root.  The script should output JSON in the format { lineCoveragePercentage: 0, branchCoveragePercentage: 0 } replacing the values lineCoveragePercentage and branchCoveragePercentage with values extracted from the coverage report.  Verify the output to ensure both values are non zero.  Ensure that all coverage files are used to calculate the total coverage, there could be more than just one file. The script should cleanup any temporary coverage files after the coverage has been calculated.  The script should explicitly build the whole library / app before running code coverage on the project.  Code coverage should use settings.runsettings.  The script should fail and bubble up any error message if any of the internally called scripts fail.  If the whole script executes correctly then none of the internal scripts should output any log messages, only the final JSON result should be returned along with a valid exit code.
- Create a utility script (called get-project-dependency-order.sh)in ./utils which returns a JSON array, where each item in the array has the format {name: "", path: "", isTestProject: true}. The output should be ordered to show the projects with the fewest dependees at the start, and the projects with the most dependees at the end.  To determine this order the script should internally determine the project graph hierarchy and then select the leaf nodes first and work its way up the tree to the root node. The script should fail and bubble up any error message if any of the internally called scripts fail.  If the whole script executes correctly then none of the internal scripts should output any log messages, only the final JSON result should be returned along with a valid exit code.
- Create a utility script (called run-project-coverage.sh) in ./utils which runs code coverage for all the unit tests within a single project, it should return a simple JSON parsable array.  The array item should be in the format { name: "MyName", path: "", lines: { coverageRatio: 0.5, covered: 123, notCovered: 123 } }.  The "name" should be the name of the class, the "path" should be the full file path relative to root.  The array should be ordered so that items with smaller coverageRatio appear at the start.  The array should be filtered so that items with coverageRatio above 0.9 are removed.  The script should accept an optional limit parameter which reduces the final array output length to that size, the default limit value should be 5.  The script should accept the full project filepath relative to the root.  Ensure that the output "path" from the get-project-dependency-order.sh script works as the input to this script.  The script should store any intermediate coverage files to a uniquely named folder under ".coverage" folder which is to be located at the project root.  The script should explicitly build the whole library / app before running code coverage on the project.  Code coverage should use settings.runsettings.  When testing the script make sure the project passed in as a parameter is not a test project.  Use GraphlessDB.DynamoDB as a project to test as it should return results.
- Create a utility script (called get-least-covered-files.sh) in ./utils which accepts an optional limit parameter.  It should internally run the get-project-dependency-order.sh script, then it should filter out any test projects (where isTestProject is true). It should then run the run-project-coverage.sh script on each remaining item in the list one at a time.  After getting the response from run-project-coverage.sh it should filter out items as follows, items with "notCovered" values of 0, items which are generated by the compiler (analyse patterns of compiler generated classes to determine this) and items which have a ratio of coverage compared to total lines (either covered or not) of 0.8 (i.e. 80% covered lines).  Then it should append the remaining items which have non zero "nonCovered" into an array.  If array length exceeds the passed in limit value or all projects have been searched then the script should return the array with its length truncated to the limit value.  The output format should be the same as the run-project-coverage.sh script. Verify that the script generates the correct output. Only use the utils scripts I've mentioned here for this task.  Ensure the script file inlines any new script rather than create any new external scripts.
- Create a utility script (called get-file-coverage.sh) in ./utils which takes the filepath of a file as input.  That argument is the target file to be covered.  There may or may not be an associated test file dedicated to providing unit testing and coverage to that target file.  If a unit test file is found then code coverage should be run just for that target file and the response returned.  The output should just be the complete coverage output. If a unit test file is not found then the output should state that the target file has no test coverage.  When generating the script ensure that a filepath extracted from the output of get-least-covered-file.sh script can be used as input to this script. The script should store any intermediate coverage files to a uniquely named folder under ".coverage" folder which is to be located at the project root.  Please note, that Coverage XML may contain just the filename, relative path, or full path so ensure that matching works for those cases.
- Create a utility script (called create-unit-test-issues.sh) in ./utils which runs get-least-covered-files.sh passing in a limit parameter of 10.  For each item in the returned array you should create a new github issue with the title "Create unit tests for {NAME}" where {NAME} is replaced with the value of the "name" property on the item.  The description of the issue should be the JSON string for this item.  Ensure the script works correctly by running with limit 1 verifying that the issue has been created, once verified the temporary issue should then be set to done.
- Create a utility script (called begin-issue.sh) in ./utils which finds a GitHub issue in GraphlessDB project which has a status of "Todo".  It should update the issue status to "In Progress" and return the issue number in the script output.  To verify that the script works you should run it against an existing issue, if it works then set the test issue status back to "Todo" again.
